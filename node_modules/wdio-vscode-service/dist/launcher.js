import fs from 'node:fs/promises';
import path from 'node:path';
import { format } from 'node:util';
import downloadBundle from '@xhmikosr/downloader';
import logger from '@wdio/logger';
import { setGlobalDispatcher, request, ProxyAgent } from 'undici';
import { download } from '@vscode/test-electron';
import { SevereServiceError } from 'webdriverio';
import { HttpsProxyAgent } from 'hpagent';
import startServer from './server/index.js';
import { fileExist, directoryExists } from './utils.js';
import { DEFAULT_CHANNEL, VSCODE_RELEASES, VSCODE_INSIDER_RELEASES, VSCODE_MANIFEST_URL, VSCODE_INSIDER_MANIFEST_URL, DEFAULT_CACHE_PATH, VSCODE_CAPABILITY_KEY, VSCODE_WEB_STANDALONE, DEFAULT_VSCODE_WEB_HOSTNAME } from './constants.js';
// set up proxy if environment variable HTTPS_PROXY or https_proxy is set
let downloadAgentConfiguration;
const httpsProxy = process.env.HTTPS_PROXY || process.env.https_proxy || process.env.npm_config_proxy;
if (httpsProxy) {
    const proxyUrl = new URL(httpsProxy);
    const token = proxyUrl.username && proxyUrl.password
        ? `Basic ${btoa(`${proxyUrl.username}:${proxyUrl.password}`)}`
        : undefined;
    setGlobalDispatcher(new ProxyAgent({ uri: proxyUrl.protocol + proxyUrl.host, token }));
    // @ts-expect-error downloadAgentConfiguration is not part of the official API
    downloadAgentConfiguration = { agent: new HttpsProxyAgent({ proxy: proxyUrl }) };
}
// use HTTPS_PROXY or https_proxy for @vscode/test-electron if not already set
if (httpsProxy !== process.env.npm_config_proxy) {
    process.env.npm_config_proxy = httpsProxy;
}
const VERSIONS_TXT = 'versions.txt';
const log = logger('wdio-vscode-service/launcher');
export default class VSCodeServiceLauncher {
    constructor(_options) {
        this._options = _options;
        this._cachePath = this._options.cachePath || DEFAULT_CACHE_PATH;
    }
    async onPrepare(_, capabilities) {
        const caps = Array.isArray(capabilities)
            ? capabilities.map((c) => (c.alwaysMatch || c))
            : Object.values(capabilities).map((c) => c.capabilities);
        /**
         * Check if we already have the VS Code bundle for the given version
         * and continue without download if possible
         */
        const versionsFilePath = path.join(this._cachePath, VERSIONS_TXT);
        const versionsFileExist = await fileExist(versionsFilePath);
        for (const cap of caps) {
            /**
             * skip setup if user is not using VSCode as capability
             */
            if (typeof cap.browserName !== 'string' || !cap[VSCODE_CAPABILITY_KEY]) {
                continue;
            }
            const version = cap[VSCODE_CAPABILITY_KEY].version || cap.browserVersion || DEFAULT_CHANNEL;
            cap[VSCODE_CAPABILITY_KEY].version = version;
            /**
             * setup VSCode Desktop
             */
            if (cap.browserName === 'vscode') {
                await this._setupVSCodeDesktop(versionsFileExist, versionsFilePath, version, cap);
                continue;
            }
            /**
             * setup VSCode Web
             */
            await this._setupVSCodeWeb(version, cap);
        }
    }
    /**
     * Set up VSCode for web testing
     * @param versionsFileExist true if we already have information stored about cached VSCode bundles
     * @param versionsFilePath string with path to cached directory
     * @param cap capabilities used for this test run
     */
    async _setupVSCodeWeb(version, cap) {
        /**
         * no need to do any work if we already started the server
         */
        if (this._vscodeServerPort || !cap[VSCODE_CAPABILITY_KEY]) {
            return;
        }
        try {
            const vscodeStandalone = await this._fetchVSCodeWebStandalone(version);
            const port = await startServer(vscodeStandalone, cap[VSCODE_CAPABILITY_KEY]);
            cap[VSCODE_CAPABILITY_KEY].serverOptions = {
                ...(cap[VSCODE_CAPABILITY_KEY].serverOptions || {
                    hostname: DEFAULT_VSCODE_WEB_HOSTNAME
                }),
                port
            };
        }
        catch (err) {
            throw new SevereServiceError(`Couldn't start server for VSCode Web: ${err.message}`);
        }
    }
    /**
     * Set up VSCode for desktop testing
     * @param versionsFileExist true if we already have information stored about cached VSCode bundles
     * @param versionsFilePath string with path to cached directory
     * @param cap capabilities used for this test run
     */
    async _setupVSCodeDesktop(versionsFileExist, versionsFilePath, version, cap) {
        if (!cap[VSCODE_CAPABILITY_KEY]) {
            throw new Error(`No key "${VSCODE_CAPABILITY_KEY}" found in caps`);
        }
        if (versionsFileExist) {
            const content = JSON.parse((await fs.readFile(versionsFilePath, 'utf-8')).toString());
            const vscodeVersion = content[version]?.vscode;
            const chromedriverVersion = content[version]?.chromedriver;
            const vscodePath = cap[VSCODE_CAPABILITY_KEY]?.binary
                || path.join(this._cachePath, `vscode-${process.platform}-${process.arch}-${vscodeVersion}`);
            if (vscodeVersion && chromedriverVersion && await fileExist(vscodePath)) {
                log.info(`Skipping download, bundle for VSCode v${vscodeVersion} already exists`);
                cap.browserVersion = chromedriverVersion;
                cap[VSCODE_CAPABILITY_KEY].binary ||= await this._downloadVSCode(vscodeVersion);
                return;
            }
        }
        const vscodeVersion = await this._fetchVSCodeVersion(version);
        const chromedriverVersion = await this._fetchChromedriverVersion(vscodeVersion);
        cap.browserVersion = chromedriverVersion;
        cap[VSCODE_CAPABILITY_KEY].binary ||= await this._downloadVSCode(vscodeVersion);
        await this._updateVersionsTxt(version, vscodeVersion, chromedriverVersion, versionsFileExist);
    }
    /**
     * Download VSCode bundle
     * @param version VSCode version
     * @returns path to downloaded VSCode bundle
     */
    async _downloadVSCode(version) {
        try {
            log.info(`Download VSCode binary (${version})`);
            return await download({
                cachePath: this._cachePath,
                version
            });
        }
        catch (err) {
            throw new SevereServiceError(`Couldn't set up VSCode: ${err.message}`);
        }
    }
    /**
     * Get VSCode version based on desired channel or validate version if provided
     * @param desiredReleaseChannel either release channel (e.g. "stable" or "insiders")
     *                              or a concrete version e.g. 1.66.0
     * @returns "main" if `desiredReleaseChannel` is "insiders" otherwise a concrete VSCode version
     */
    async _fetchVSCodeVersion(desiredReleaseChannel) {
        try {
            if (desiredReleaseChannel === 'insiders') {
                log.info(`Fetch latest insider release from ${VSCODE_INSIDER_RELEASES}`);
                const { body: versions } = await request(VSCODE_INSIDER_RELEASES, {});
                const availableVersions = await versions.json();
                return availableVersions[0];
            }
            log.info(`Fetch releases from ${VSCODE_RELEASES}`);
            const { body: versions } = await request(VSCODE_RELEASES, {});
            const availableVersions = await versions.json();
            if (desiredReleaseChannel) {
                /**
                 * validate provided VSCode version
                 */
                const newDesiredReleaseChannel = desiredReleaseChannel === 'stable'
                    ? availableVersions[0]
                    : desiredReleaseChannel;
                if (!availableVersions.includes(newDesiredReleaseChannel)) {
                    throw new Error(`Desired version "${newDesiredReleaseChannel}" is not existent, available versions:`
                        + `${availableVersions.slice(0, 5).join(', ')}..., see ${VSCODE_RELEASES}`);
                }
                return newDesiredReleaseChannel;
            }
            return availableVersions[0];
        }
        catch (err) {
            throw new SevereServiceError(`Couldn't fetch latest VSCode: ${err.message}`);
        }
    }
    /**
     * Fetches required Chromedriver version for given VSCode version
     * @param vscodeVersion branch or tag version of VSCode repository
     * @returns required Chromedriver version
     */
    async _fetchChromedriverVersion(vscodeVersion) {
        try {
            const manifestUrl = vscodeVersion.includes('insider')
                ? VSCODE_INSIDER_MANIFEST_URL
                : format(VSCODE_MANIFEST_URL, vscodeVersion);
            log.info(`manifest url: ${manifestUrl}`);
            const { body } = await request(manifestUrl, {});
            const manifest = await body.json();
            const chromium = manifest.registrations.find((r) => r.component.git.name === 'chromium');
            if (!chromium) {
                throw new Error('Can\'t find chromium version in manifest response');
            }
            return chromium.version.split('.')[0];
        }
        catch (err) {
            throw new SevereServiceError(`Couldn't fetch Chromedriver version: ${err.message}`);
        }
    }
    /**
     * Fetches VSCode Web files
     * ToDo(Christian): allow to define a local VSCode development path
     *                  to be able to skip this part
     */
    async _fetchVSCodeWebStandalone(vscodeVersion) {
        if (vscodeVersion !== 'stable' && vscodeVersion !== 'insiders') {
            throw new Error('Running VSCode in the browser is only supported for "stable" and "insiders" version');
        }
        try {
            const { body } = await request(format(VSCODE_WEB_STANDALONE, vscodeVersion), {});
            const info = await body.json();
            const folder = path.join(this._cachePath, `vscode-web-${vscodeVersion}-${info.version}`);
            if (!(await directoryExists(folder))) {
                await downloadBundle(info.url, folder, { extract: true, strip: 1, ...downloadAgentConfiguration });
            }
            return { path: folder, vscodeVersion, version: info.version };
        }
        catch (err) {
            throw new SevereServiceError(`Couldn't set up VSCode Web: ${err.message}`);
        }
    }
    async _updateVersionsTxt(version, vscodeVersion, chromedriverVersion, versionsFileExist) {
        const newContent = {
            [version]: {
                chromedriver: chromedriverVersion,
                vscode: vscodeVersion
            }
        };
        const versionsTxtPath = path.join(this._cachePath, VERSIONS_TXT);
        if (!versionsFileExist) {
            return fs.writeFile(versionsTxtPath, JSON.stringify(newContent, null, 4), 'utf-8');
        }
        const content = JSON.parse((await fs.readFile(versionsTxtPath, 'utf-8')).toString());
        return fs.writeFile(versionsTxtPath, JSON.stringify({ ...content, ...newContent }, null, 4), 'utf-8');
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGF1bmNoZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvbGF1bmNoZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLE1BQU0sa0JBQWtCLENBQUE7QUFDakMsT0FBTyxJQUFJLE1BQU0sV0FBVyxDQUFBO0FBQzVCLE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSxXQUFXLENBQUE7QUFFbEMsT0FBTyxjQUFtQyxNQUFNLHNCQUFzQixDQUFBO0FBQ3RFLE9BQU8sTUFBTSxNQUFNLGNBQWMsQ0FBQTtBQUNqQyxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLFFBQVEsQ0FBQTtBQUNqRSxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0sdUJBQXVCLENBQUE7QUFDaEQsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sYUFBYSxDQUFBO0FBRWhELE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxTQUFTLENBQUE7QUFFekMsT0FBTyxXQUFXLE1BQU0sbUJBQW1CLENBQUE7QUFDM0MsT0FBTyxFQUFFLFNBQVMsRUFBRSxlQUFlLEVBQUUsTUFBTSxZQUFZLENBQUE7QUFDdkQsT0FBTyxFQUNILGVBQWUsRUFBRSxlQUFlLEVBQUUsdUJBQXVCLEVBQUUsbUJBQW1CLEVBQUUsMkJBQTJCLEVBQzNHLGtCQUFrQixFQUFFLHFCQUFxQixFQUFFLHFCQUFxQixFQUFFLDJCQUEyQixFQUNoRyxNQUFNLGdCQUFnQixDQUFBO0FBdUJ2Qix5RUFBeUU7QUFDekUsSUFBSSwwQkFBZ0UsQ0FBQTtBQUNwRSxNQUFNLFVBQVUsR0FBRyxPQUFPLENBQUMsR0FBRyxDQUFDLFdBQVcsSUFBSSxPQUFPLENBQUMsR0FBRyxDQUFDLFdBQVcsSUFBSSxPQUFPLENBQUMsR0FBRyxDQUFDLGdCQUFnQixDQUFBO0FBQ3JHLElBQUksVUFBVSxFQUFFLENBQUM7SUFDYixNQUFNLFFBQVEsR0FBRyxJQUFJLEdBQUcsQ0FBQyxV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U0FBUyxDQUFDLEVBQUUsR0FBRyxPQUFPLEVBQUUsR0FBRyxVQUFVLEVBQUUsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLEVBQ3RELE9BQU8sQ0FDVixDQUFBO0lBQ0wsQ0FBQztDQUNKIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGZzIGZyb20gJ25vZGU6ZnMvcHJvbWlzZXMnXG5pbXBvcnQgcGF0aCBmcm9tICdub2RlOnBhdGgnXG5pbXBvcnQgeyBmb3JtYXQgfSBmcm9tICdub2RlOnV0aWwnXG5cbmltcG9ydCBkb3dubG9hZEJ1bmRsZSwgeyBEb3dubG9hZE9wdGlvbnMgfSBmcm9tICdAeGhtaWtvc3IvZG93bmxvYWRlcidcbmltcG9ydCBsb2dnZXIgZnJvbSAnQHdkaW8vbG9nZ2VyJ1xuaW1wb3J0IHsgc2V0R2xvYmFsRGlzcGF0Y2hlciwgcmVxdWVzdCwgUHJveHlBZ2VudCB9IGZyb20gJ3VuZGljaSdcbmltcG9ydCB7IGRvd25sb2FkIH0gZnJvbSAnQHZzY29kZS90ZXN0LWVsZWN0cm9uJ1xuaW1wb3J0IHsgU2V2ZXJlU2VydmljZUVycm9yIH0gZnJvbSAnd2ViZHJpdmVyaW8nXG5pbXBvcnQgdHlwZSB7IENhcGFiaWxpdGllcyB9IGZyb20gJ0B3ZGlvL3R5cGVzJ1xuaW1wb3J0IHsgSHR0cHNQcm94eUFnZW50IH0gZnJvbSAnaHBhZ2VudCdcblxuaW1wb3J0IHN0YXJ0U2VydmVyIGZyb20gJy4vc2VydmVyL2luZGV4LmpzJ1xuaW1wb3J0IHsgZmlsZUV4aXN0LCBkaXJlY3RvcnlFeGlzdHMgfSBmcm9tICcuL3V0aWxzLmpzJ1xuaW1wb3J0IHtcbiAgICBERUZBVUxUX0NIQU5ORUwsIFZTQ09ERV9SRUxFQVNFUywgVlNDT0RFX0lOU0lERVJfUkVMRUFTRVMsIFZTQ09ERV9NQU5JRkVTVF9VUkwsIFZTQ09ERV9JTlNJREVSX01BTklGRVNUX1VSTCxcbiAgICBERUZBVUxUX0NBQ0hFX1BBVEgsIFZTQ09ERV9DQVBBQklMSVRZX0tFWSwgVlNDT0RFX1dFQl9TVEFOREFMT05FLCBERUZBVUxUX1ZTQ09ERV9XRUJfSE9TVE5BTUVcbn0gZnJvbSAnLi9jb25zdGFudHMuanMnXG5pbXBvcnQgdHlwZSB7XG4gICAgU2VydmljZU9wdGlvbnMsIFZTQ29kZUNhcGFiaWxpdGllcywgV2ViU3RhbmRhbG9uZVJlc3BvbnNlLFxuICAgIEJ1bmRsZVxufSBmcm9tICcuL3R5cGVzLmpzJ1xuXG5pbnRlcmZhY2UgQnVuZGxlSW5mb3JtYXRpb24ge1xuICAgIGNocm9tZWRyaXZlcjogc3RyaW5nXG4gICAgdnNjb2RlOiBzdHJpbmdcbn1cbmludGVyZmFjZSBNYW5pZmVzdCB7XG4gICAgcmVnaXN0cmF0aW9uczogUmVnaXN0cmF0aW9uW11cbn1cbmludGVyZmFjZSBSZWdpc3RyYXRpb24ge1xuICAgIHZlcnNpb246IHN0cmluZ1xuICAgIGNvbXBvbmVudDoge1xuICAgICAgICBnaXQ6IHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICB9XG4gICAgfVxufVxudHlwZSBWZXJzaW9ucyA9IHsgW2Rlc2lyZWRWZXJzaW9uOiBzdHJpbmddOiBCdW5kbGVJbmZvcm1hdGlvbiB8IHVuZGVmaW5lZCB9XG5cbi8vIHNldCB1cCBwcm94eSBpZiBlbnZpcm9ubWVudCB2YXJpYWJsZSBIVFRQU19QUk9YWSBvciBodHRwc19wcm94eSBpcyBzZXRcbmxldCBkb3dubG9hZEFnZW50Q29uZmlndXJhdGlvbjogUGFydGlhbDxEb3dubG9hZE9wdGlvbnM+IHwgdW5kZWZpbmVkXG5jb25zdCBodHRwc1Byb3h5ID0gcHJvY2Vzcy5lbnYuSFRUUFNfUFJPWFkgfHwgcHJvY2Vzcy5lbnYuaHR0cHNfcHJveHkgfHwgcHJvY2Vzcy5lbnYubnBtX2NvbmZpZ19wcm94eVxuaWYgKGh0dHBzUHJveHkpIHtcbiAgICBjb25zdCBwcm94eVVybCA9IG5ldyBVUkwoaHR0cHNQcm94eSlcbiAgICBjb25zdCB0b2tlbiA9IHByb3h5VXJsLnVzZXJuYW1lICYmIHByb3h5VXJsLnBhc3N3b3JkXG4gICAgICAgID8gYEJhc2ljICR7YnRvYShgJHtwcm94eVVybC51c2VybmFtZX06JHtwcm94eVVybC5wYXNzd29yZH1gKX1gXG4gICAgICAgIDogdW5kZWZpbmVkXG5cbiAgICBzZXRHbG9iYWxEaXNwYXRjaGVyKG5ldyBQcm94eUFnZW50KHsgdXJpOiBwcm94eVVybC5wcm90b2NvbCArIHByb3h5VXJsLmhvc3QsIHRva2VuIH0pKVxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgZG93bmxvYWRBZ2VudENvbmZpZ3VyYXRpb24gaXMgbm90IHBhcnQgb2YgdGhlIG9mZmljaWFsIEFQSVxuICAgIGRvd25sb2FkQWdlbnRDb25maWd1cmF0aW9uID0geyBhZ2VudDogbmV3IEh0dHBzUHJveHlBZ2VudCh7IHByb3h5OiBwcm94eVVybCB9KSB9XG59XG4vLyB1c2UgSFRUUFNfUFJPWFkgb3IgaHR0cHNfcHJveHkgZm9yIEB2c2NvZGUvdGVzdC1lbGVjdHJvbiBpZiBub3QgYWxyZWFkeSBzZXRcbmlmIChodHRwc1Byb3h5ICE9PSBwcm9jZXNzLmVudi5ucG1fY29uZmlnX3Byb3h5KSB7XG4gICAgcHJvY2Vzcy5lbnYubnBtX2NvbmZpZ19wcm94eSA9IGh0dHBzUHJveHlcbn1cblxuY29uc3QgVkVSU0lPTlNfVFhUID0gJ3ZlcnNpb25zLnR4dCdcbmNvbnN0IGxvZyA9IGxvZ2dlcignd2Rpby12c2NvZGUtc2VydmljZS9sYXVuY2hlcicpXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWU0NvZGVTZXJ2aWNlTGF1bmNoZXIge1xuICAgIHByaXZhdGUgX2NhY2hlUGF0aDogc3RyaW5nXG4gICAgcHJpdmF0ZSBfdnNjb2RlU2VydmVyUG9ydD86IG51bWJlclxuXG4gICAgY29uc3RydWN0b3IgKHByaXZhdGUgX29wdGlvbnM6IFNlcnZpY2VPcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX2NhY2hlUGF0aCA9IHRoaXMuX29wdGlvbnMuY2FjaGVQYXRoIHx8IERFRkFVTFRfQ0FDSEVfUEFUSFxuICAgIH1cblxuICAgIGFzeW5jIG9uUHJlcGFyZSAoXzogbmV2ZXIsIGNhcGFiaWxpdGllczogQ2FwYWJpbGl0aWVzLlJlbW90ZUNhcGFiaWxpdGllcykge1xuICAgICAgICBjb25zdCBjYXBzOiBWU0NvZGVDYXBhYmlsaXRpZXNbXSA9IEFycmF5LmlzQXJyYXkoY2FwYWJpbGl0aWVzKVxuICAgICAgICAgICAgPyBjYXBhYmlsaXRpZXMubWFwKChjKSA9PiAoKGMgYXMgQ2FwYWJpbGl0aWVzLlczQ0NhcGFiaWxpdGllcykuYWx3YXlzTWF0Y2ggfHwgYykgYXMgVlNDb2RlQ2FwYWJpbGl0aWVzKVxuICAgICAgICAgICAgOiBPYmplY3QudmFsdWVzKGNhcGFiaWxpdGllcykubWFwKChjKSA9PiBjLmNhcGFiaWxpdGllcyBhcyBWU0NvZGVDYXBhYmlsaXRpZXMpXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrIGlmIHdlIGFscmVhZHkgaGF2ZSB0aGUgVlMgQ29kZSBidW5kbGUgZm9yIHRoZSBnaXZlbiB2ZXJzaW9uXG4gICAgICAgICAqIGFuZCBjb250aW51ZSB3aXRob3V0IGRvd25sb2FkIGlmIHBvc3NpYmxlXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCB2ZXJzaW9uc0ZpbGVQYXRoID0gcGF0aC5qb2luKHRoaXMuX2NhY2hlUGF0aCwgVkVSU0lPTlNfVFhUKVxuICAgICAgICBjb25zdCB2ZXJzaW9uc0ZpbGVFeGlzdCA9IGF3YWl0IGZpbGVFeGlzdCh2ZXJzaW9uc0ZpbGVQYXRoKVxuXG4gICAgICAgIGZvciAoY29uc3QgY2FwIG9mIGNhcHMpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogc2tpcCBzZXR1cCBpZiB1c2VyIGlzIG5vdCB1c2luZyBWU0NvZGUgYXMgY2FwYWJpbGl0eVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNhcC5icm93c2VyTmFtZSAhPT0gJ3N0cmluZycgfHwgIWNhcFtWU0NPREVfQ0FQQUJJTElUWV9LRVldKSB7XG4gICAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgdmVyc2lvbiA9IGNhcFtWU0NPREVfQ0FQQUJJTElUWV9LRVldLnZlcnNpb24gfHwgY2FwLmJyb3dzZXJWZXJzaW9uIHx8IERFRkFVTFRfQ0hBTk5FTFxuICAgICAgICAgICAgY2FwW1ZTQ09ERV9DQVBBQklMSVRZX0tFWV0udmVyc2lvbiA9IHZlcnNpb25cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBzZXR1cCBWU0NvZGUgRGVza3RvcFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoY2FwLmJyb3dzZXJOYW1lID09PSAndnNjb2RlJykge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NldHVwVlNDb2RlRGVza3RvcCh2ZXJzaW9uc0ZpbGVFeGlzdCwgdmVyc2lvbnNGaWxlUGF0aCwgdmVyc2lvbiwgY2FwKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogc2V0dXAgVlNDb2RlIFdlYlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9zZXR1cFZTQ29kZVdlYih2ZXJzaW9uLCBjYXApXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdXAgVlNDb2RlIGZvciB3ZWIgdGVzdGluZ1xuICAgICAqIEBwYXJhbSB2ZXJzaW9uc0ZpbGVFeGlzdCB0cnVlIGlmIHdlIGFscmVhZHkgaGF2ZSBpbmZvcm1hdGlvbiBzdG9yZWQgYWJvdXQgY2FjaGVkIFZTQ29kZSBidW5kbGVzXG4gICAgICogQHBhcmFtIHZlcnNpb25zRmlsZVBhdGggc3RyaW5nIHdpdGggcGF0aCB0byBjYWNoZWQgZGlyZWN0b3J5XG4gICAgICogQHBhcmFtIGNhcCBjYXBhYmlsaXRpZXMgdXNlZCBmb3IgdGhpcyB0ZXN0IHJ1blxuICAgICAqL1xuICAgIHByaXZhdGUgYXN5bmMgX3NldHVwVlNDb2RlV2ViIChcbiAgICAgICAgdmVyc2lvbjogc3RyaW5nLFxuICAgICAgICBjYXA6IFZTQ29kZUNhcGFiaWxpdGllc1xuICAgICkge1xuICAgICAgICAvKipcbiAgICAgICAgICogbm8gbmVlZCB0byBkbyBhbnkgd29yayBpZiB3ZSBhbHJlYWR5IHN0YXJ0ZWQgdGhlIHNlcnZlclxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHRoaXMuX3ZzY29kZVNlcnZlclBvcnQgfHwgIWNhcFtWU0NPREVfQ0FQQUJJTElUWV9LRVldKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB2c2NvZGVTdGFuZGFsb25lID0gYXdhaXQgdGhpcy5fZmV0Y2hWU0NvZGVXZWJTdGFuZGFsb25lKHZlcnNpb24pXG4gICAgICAgICAgICBjb25zdCBwb3J0ID0gYXdhaXQgc3RhcnRTZXJ2ZXIodnNjb2RlU3RhbmRhbG9uZSwgY2FwW1ZTQ09ERV9DQVBBQklMSVRZX0tFWV0pXG4gICAgICAgICAgICBjYXBbVlNDT0RFX0NBUEFCSUxJVFlfS0VZXS5zZXJ2ZXJPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIC4uLihjYXBbVlNDT0RFX0NBUEFCSUxJVFlfS0VZXS5zZXJ2ZXJPcHRpb25zIHx8IHtcbiAgICAgICAgICAgICAgICAgICAgaG9zdG5hbWU6IERFRkFVTFRfVlNDT0RFX1dFQl9IT1NUTkFNRVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHBvcnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTZXZlcmVTZXJ2aWNlRXJyb3IoYENvdWxkbid0IHN0YXJ0IHNlcnZlciBmb3IgVlNDb2RlIFdlYjogJHtlcnIubWVzc2FnZX1gKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHVwIFZTQ29kZSBmb3IgZGVza3RvcCB0ZXN0aW5nXG4gICAgICogQHBhcmFtIHZlcnNpb25zRmlsZUV4aXN0IHRydWUgaWYgd2UgYWxyZWFkeSBoYXZlIGluZm9ybWF0aW9uIHN0b3JlZCBhYm91dCBjYWNoZWQgVlNDb2RlIGJ1bmRsZXNcbiAgICAgKiBAcGFyYW0gdmVyc2lvbnNGaWxlUGF0aCBzdHJpbmcgd2l0aCBwYXRoIHRvIGNhY2hlZCBkaXJlY3RvcnlcbiAgICAgKiBAcGFyYW0gY2FwIGNhcGFiaWxpdGllcyB1c2VkIGZvciB0aGlzIHRlc3QgcnVuXG4gICAgICovXG4gICAgcHJpdmF0ZSBhc3luYyBfc2V0dXBWU0NvZGVEZXNrdG9wIChcbiAgICAgICAgdmVyc2lvbnNGaWxlRXhpc3Q6IGJvb2xlYW4sXG4gICAgICAgIHZlcnNpb25zRmlsZVBhdGg6IHN0cmluZyxcbiAgICAgICAgdmVyc2lvbjogc3RyaW5nLFxuICAgICAgICBjYXA6IFZTQ29kZUNhcGFiaWxpdGllc1xuICAgICkge1xuICAgICAgICBpZiAoIWNhcFtWU0NPREVfQ0FQQUJJTElUWV9LRVldKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGtleSBcIiR7VlNDT0RFX0NBUEFCSUxJVFlfS0VZfVwiIGZvdW5kIGluIGNhcHNgKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZlcnNpb25zRmlsZUV4aXN0KSB7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50ID0gSlNPTi5wYXJzZSgoYXdhaXQgZnMucmVhZEZpbGUodmVyc2lvbnNGaWxlUGF0aCwgJ3V0Zi04JykpLnRvU3RyaW5nKCkpIGFzIFZlcnNpb25zXG5cbiAgICAgICAgICAgIGNvbnN0IHZzY29kZVZlcnNpb24gPSBjb250ZW50W3ZlcnNpb25dPy52c2NvZGVcbiAgICAgICAgICAgIGNvbnN0IGNocm9tZWRyaXZlclZlcnNpb24gPSBjb250ZW50W3ZlcnNpb25dPy5jaHJvbWVkcml2ZXJcbiAgICAgICAgICAgIGNvbnN0IHZzY29kZVBhdGggPSBjYXBbVlNDT0RFX0NBUEFCSUxJVFlfS0VZXT8uYmluYXJ5XG4gICAgICAgICAgICAgICAgfHwgcGF0aC5qb2luKHRoaXMuX2NhY2hlUGF0aCwgYHZzY29kZS0ke3Byb2Nlc3MucGxhdGZvcm19LSR7cHJvY2Vzcy5hcmNofS0ke3ZzY29kZVZlcnNpb259YClcblxuICAgICAgICAgICAgaWYgKHZzY29kZVZlcnNpb24gJiYgY2hyb21lZHJpdmVyVmVyc2lvbiAmJiBhd2FpdCBmaWxlRXhpc3QodnNjb2RlUGF0aCkpIHtcbiAgICAgICAgICAgICAgICBsb2cuaW5mbyhcbiAgICAgICAgICAgICAgICAgICAgYFNraXBwaW5nIGRvd25sb2FkLCBidW5kbGUgZm9yIFZTQ29kZSB2JHt2c2NvZGVWZXJzaW9ufSBhbHJlYWR5IGV4aXN0c2BcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgY2FwLmJyb3dzZXJWZXJzaW9uID0gY2hyb21lZHJpdmVyVmVyc2lvblxuICAgICAgICAgICAgICAgIGNhcFtWU0NPREVfQ0FQQUJJTElUWV9LRVldLmJpbmFyeSB8fD0gYXdhaXQgdGhpcy5fZG93bmxvYWRWU0NvZGUodnNjb2RlVmVyc2lvbilcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHZzY29kZVZlcnNpb24gPSBhd2FpdCB0aGlzLl9mZXRjaFZTQ29kZVZlcnNpb24odmVyc2lvbilcbiAgICAgICAgY29uc3QgY2hyb21lZHJpdmVyVmVyc2lvbiA9IGF3YWl0IHRoaXMuX2ZldGNoQ2hyb21lZHJpdmVyVmVyc2lvbih2c2NvZGVWZXJzaW9uKVxuXG4gICAgICAgIGNhcC5icm93c2VyVmVyc2lvbiA9IGNocm9tZWRyaXZlclZlcnNpb25cbiAgICAgICAgY2FwW1ZTQ09ERV9DQVBBQklMSVRZX0tFWV0uYmluYXJ5IHx8PSBhd2FpdCB0aGlzLl9kb3dubG9hZFZTQ29kZSh2c2NvZGVWZXJzaW9uKVxuICAgICAgICBhd2FpdCB0aGlzLl91cGRhdGVWZXJzaW9uc1R4dCh2ZXJzaW9uLCB2c2NvZGVWZXJzaW9uLCBjaHJvbWVkcml2ZXJWZXJzaW9uLCB2ZXJzaW9uc0ZpbGVFeGlzdClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEb3dubG9hZCBWU0NvZGUgYnVuZGxlXG4gICAgICogQHBhcmFtIHZlcnNpb24gVlNDb2RlIHZlcnNpb25cbiAgICAgKiBAcmV0dXJucyBwYXRoIHRvIGRvd25sb2FkZWQgVlNDb2RlIGJ1bmRsZVxuICAgICAqL1xuICAgIHByaXZhdGUgYXN5bmMgX2Rvd25sb2FkVlNDb2RlICh2ZXJzaW9uOiBzdHJpbmcpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxvZy5pbmZvKGBEb3dubG9hZCBWU0NvZGUgYmluYXJ5ICgke3ZlcnNpb259KWApXG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgZG93bmxvYWQoe1xuICAgICAgICAgICAgICAgIGNhY2hlUGF0aDogdGhpcy5fY2FjaGVQYXRoLFxuICAgICAgICAgICAgICAgIHZlcnNpb25cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU2V2ZXJlU2VydmljZUVycm9yKGBDb3VsZG4ndCBzZXQgdXAgVlNDb2RlOiAke2Vyci5tZXNzYWdlfWApXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgVlNDb2RlIHZlcnNpb24gYmFzZWQgb24gZGVzaXJlZCBjaGFubmVsIG9yIHZhbGlkYXRlIHZlcnNpb24gaWYgcHJvdmlkZWRcbiAgICAgKiBAcGFyYW0gZGVzaXJlZFJlbGVhc2VDaGFubmVsIGVpdGhlciByZWxlYXNlIGNoYW5uZWwgKGUuZy4gXCJzdGFibGVcIiBvciBcImluc2lkZXJzXCIpXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvciBhIGNvbmNyZXRlIHZlcnNpb24gZS5nLiAxLjY2LjBcbiAgICAgKiBAcmV0dXJucyBcIm1haW5cIiBpZiBgZGVzaXJlZFJlbGVhc2VDaGFubmVsYCBpcyBcImluc2lkZXJzXCIgb3RoZXJ3aXNlIGEgY29uY3JldGUgVlNDb2RlIHZlcnNpb25cbiAgICAgKi9cbiAgICBwcml2YXRlIGFzeW5jIF9mZXRjaFZTQ29kZVZlcnNpb24gKGRlc2lyZWRSZWxlYXNlQ2hhbm5lbD86IHN0cmluZykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGRlc2lyZWRSZWxlYXNlQ2hhbm5lbCA9PT0gJ2luc2lkZXJzJykge1xuICAgICAgICAgICAgICAgIGxvZy5pbmZvKGBGZXRjaCBsYXRlc3QgaW5zaWRlciByZWxlYXNlIGZyb20gJHtWU0NPREVfSU5TSURFUl9SRUxFQVNFU31gKVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgYm9keTogdmVyc2lvbnMgfSA9IGF3YWl0IHJlcXVlc3QoVlNDT0RFX0lOU0lERVJfUkVMRUFTRVMsIHt9KVxuICAgICAgICAgICAgICAgIGNvbnN0IGF2YWlsYWJsZVZlcnNpb25zOiBzdHJpbmdbXSA9IGF3YWl0IHZlcnNpb25zLmpzb24oKSBhcyBzdHJpbmdbXVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGF2YWlsYWJsZVZlcnNpb25zWzBdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2cuaW5mbyhgRmV0Y2ggcmVsZWFzZXMgZnJvbSAke1ZTQ09ERV9SRUxFQVNFU31gKVxuICAgICAgICAgICAgY29uc3QgeyBib2R5OiB2ZXJzaW9ucyB9ID0gYXdhaXQgcmVxdWVzdChWU0NPREVfUkVMRUFTRVMsIHt9KVxuICAgICAgICAgICAgY29uc3QgYXZhaWxhYmxlVmVyc2lvbnM6IHN0cmluZ1tdID0gYXdhaXQgdmVyc2lvbnMuanNvbigpIGFzIHN0cmluZ1tdXG5cbiAgICAgICAgICAgIGlmIChkZXNpcmVkUmVsZWFzZUNoYW5uZWwpIHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiB2YWxpZGF0ZSBwcm92aWRlZCBWU0NvZGUgdmVyc2lvblxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0Rlc2lyZWRSZWxlYXNlQ2hhbm5lbCA9IGRlc2lyZWRSZWxlYXNlQ2hhbm5lbCA9PT0gJ3N0YWJsZSdcbiAgICAgICAgICAgICAgICAgICAgPyBhdmFpbGFibGVWZXJzaW9uc1swXVxuICAgICAgICAgICAgICAgICAgICA6IGRlc2lyZWRSZWxlYXNlQ2hhbm5lbFxuICAgICAgICAgICAgICAgIGlmICghYXZhaWxhYmxlVmVyc2lvbnMuaW5jbHVkZXMobmV3RGVzaXJlZFJlbGVhc2VDaGFubmVsKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICBgRGVzaXJlZCB2ZXJzaW9uIFwiJHtuZXdEZXNpcmVkUmVsZWFzZUNoYW5uZWx9XCIgaXMgbm90IGV4aXN0ZW50LCBhdmFpbGFibGUgdmVyc2lvbnM6YFxuICAgICAgICAgICAgICAgICAgICAgICAgKyBgJHthdmFpbGFibGVWZXJzaW9ucy5zbGljZSgwLCA1KS5qb2luKCcsICcpfS4uLiwgc2VlICR7VlNDT0RFX1JFTEVBU0VTfWBcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBuZXdEZXNpcmVkUmVsZWFzZUNoYW5uZWxcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGF2YWlsYWJsZVZlcnNpb25zWzBdXG4gICAgICAgIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU2V2ZXJlU2VydmljZUVycm9yKGBDb3VsZG4ndCBmZXRjaCBsYXRlc3QgVlNDb2RlOiAke2Vyci5tZXNzYWdlfWApXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIHJlcXVpcmVkIENocm9tZWRyaXZlciB2ZXJzaW9uIGZvciBnaXZlbiBWU0NvZGUgdmVyc2lvblxuICAgICAqIEBwYXJhbSB2c2NvZGVWZXJzaW9uIGJyYW5jaCBvciB0YWcgdmVyc2lvbiBvZiBWU0NvZGUgcmVwb3NpdG9yeVxuICAgICAqIEByZXR1cm5zIHJlcXVpcmVkIENocm9tZWRyaXZlciB2ZXJzaW9uXG4gICAgICovXG4gICAgcHJpdmF0ZSBhc3luYyBfZmV0Y2hDaHJvbWVkcml2ZXJWZXJzaW9uICh2c2NvZGVWZXJzaW9uOiBzdHJpbmcpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IG1hbmlmZXN0VXJsID0gdnNjb2RlVmVyc2lvbi5pbmNsdWRlcygnaW5zaWRlcicpXG4gICAgICAgICAgICAgICAgPyBWU0NPREVfSU5TSURFUl9NQU5JRkVTVF9VUkxcbiAgICAgICAgICAgICAgICA6IGZvcm1hdChWU0NPREVfTUFOSUZFU1RfVVJMLCB2c2NvZGVWZXJzaW9uKVxuXG4gICAgICAgICAgICBsb2cuaW5mbyhgbWFuaWZlc3QgdXJsOiAke21hbmlmZXN0VXJsfWApXG4gICAgICAgICAgICBjb25zdCB7IGJvZHkgfSA9IGF3YWl0IHJlcXVlc3QobWFuaWZlc3RVcmwsIHt9KVxuICAgICAgICAgICAgY29uc3QgbWFuaWZlc3QgPSBhd2FpdCBib2R5Lmpzb24oKSBhcyBNYW5pZmVzdFxuICAgICAgICAgICAgY29uc3QgY2hyb21pdW0gPSBtYW5pZmVzdC5yZWdpc3RyYXRpb25zLmZpbmQoKHI6IGFueSkgPT4gci5jb21wb25lbnQuZ2l0Lm5hbWUgPT09ICdjaHJvbWl1bScpXG5cbiAgICAgICAgICAgIGlmICghY2hyb21pdW0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3QgZmluZCBjaHJvbWl1bSB2ZXJzaW9uIGluIG1hbmlmZXN0IHJlc3BvbnNlJylcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNocm9taXVtLnZlcnNpb24uc3BsaXQoJy4nKVswXVxuICAgICAgICB9IGNhdGNoIChlcnI6IGFueSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFNldmVyZVNlcnZpY2VFcnJvcihgQ291bGRuJ3QgZmV0Y2ggQ2hyb21lZHJpdmVyIHZlcnNpb246ICR7ZXJyLm1lc3NhZ2V9YClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgVlNDb2RlIFdlYiBmaWxlc1xuICAgICAqIFRvRG8oQ2hyaXN0aWFuKTogYWxsb3cgdG8gZGVmaW5lIGEgbG9jYWwgVlNDb2RlIGRldmVsb3BtZW50IHBhdGhcbiAgICAgKiAgICAgICAgICAgICAgICAgIHRvIGJlIGFibGUgdG8gc2tpcCB0aGlzIHBhcnRcbiAgICAgKi9cbiAgICBwcml2YXRlIGFzeW5jIF9mZXRjaFZTQ29kZVdlYlN0YW5kYWxvbmUgKHZzY29kZVZlcnNpb246IHN0cmluZyk6IFByb21pc2U8QnVuZGxlPiB7XG4gICAgICAgIGlmICh2c2NvZGVWZXJzaW9uICE9PSAnc3RhYmxlJyAmJiB2c2NvZGVWZXJzaW9uICE9PSAnaW5zaWRlcnMnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1J1bm5pbmcgVlNDb2RlIGluIHRoZSBicm93c2VyIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBcInN0YWJsZVwiIGFuZCBcImluc2lkZXJzXCIgdmVyc2lvbicpXG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyBib2R5IH0gPSBhd2FpdCByZXF1ZXN0KGZvcm1hdChWU0NPREVfV0VCX1NUQU5EQUxPTkUsIHZzY29kZVZlcnNpb24pLCB7fSlcbiAgICAgICAgICAgIGNvbnN0IGluZm8gPSBhd2FpdCBib2R5Lmpzb24oKSBhcyBXZWJTdGFuZGFsb25lUmVzcG9uc2VcbiAgICAgICAgICAgIGNvbnN0IGZvbGRlciA9IHBhdGguam9pbih0aGlzLl9jYWNoZVBhdGgsIGB2c2NvZGUtd2ViLSR7dnNjb2RlVmVyc2lvbn0tJHtpbmZvLnZlcnNpb259YClcblxuICAgICAgICAgICAgaWYgKCEoYXdhaXQgZGlyZWN0b3J5RXhpc3RzKGZvbGRlcikpKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgZG93bmxvYWRCdW5kbGUoaW5mby51cmwsIGZvbGRlciwgeyBleHRyYWN0OiB0cnVlLCBzdHJpcDogMSwgLi4uZG93bmxvYWRBZ2VudENvbmZpZ3VyYXRpb24gfSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHsgcGF0aDogZm9sZGVyLCB2c2NvZGVWZXJzaW9uLCB2ZXJzaW9uOiBpbmZvLnZlcnNpb24gfVxuICAgICAgICB9IGNhdGNoIChlcnI6IGFueSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFNldmVyZVNlcnZpY2VFcnJvcihgQ291bGRuJ3Qgc2V0IHVwIFZTQ29kZSBXZWI6ICR7ZXJyLm1lc3NhZ2V9YClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgX3VwZGF0ZVZlcnNpb25zVHh0IChcbiAgICAgICAgdmVyc2lvbjogc3RyaW5nLFxuICAgICAgICB2c2NvZGVWZXJzaW9uOiBzdHJpbmcsXG4gICAgICAgIGNocm9tZWRyaXZlclZlcnNpb246IHN0cmluZyxcbiAgICAgICAgdmVyc2lvbnNGaWxlRXhpc3Q6IGJvb2xlYW5cbiAgICApIHtcbiAgICAgICAgY29uc3QgbmV3Q29udGVudDogVmVyc2lvbnMgPSB7XG4gICAgICAgICAgICBbdmVyc2lvbl06IHtcbiAgICAgICAgICAgICAgICBjaHJvbWVkcml2ZXI6IGNocm9tZWRyaXZlclZlcnNpb24sXG4gICAgICAgICAgICAgICAgdnNjb2RlOiB2c2NvZGVWZXJzaW9uXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmVyc2lvbnNUeHRQYXRoID0gcGF0aC5qb2luKHRoaXMuX2NhY2hlUGF0aCwgVkVSU0lPTlNfVFhUKVxuICAgICAgICBpZiAoIXZlcnNpb25zRmlsZUV4aXN0KSB7XG4gICAgICAgICAgICByZXR1cm4gZnMud3JpdGVGaWxlKFxuICAgICAgICAgICAgICAgIHZlcnNpb25zVHh0UGF0aCxcbiAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShuZXdDb250ZW50LCBudWxsLCA0KSxcbiAgICAgICAgICAgICAgICAndXRmLTgnXG4gICAgICAgICAgICApXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjb250ZW50ID0gSlNPTi5wYXJzZSgoYXdhaXQgZnMucmVhZEZpbGUodmVyc2lvbnNUeHRQYXRoLCAndXRmLTgnKSkudG9TdHJpbmcoKSlcbiAgICAgICAgcmV0dXJuIGZzLndyaXRlRmlsZShcbiAgICAgICAgICAgIHZlcnNpb25zVHh0UGF0aCxcbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHsgLi4uY29udGVudCwgLi4ubmV3Q29udGVudCB9LCBudWxsLCA0KSxcbiAgICAgICAgICAgICd1dGYtOCdcbiAgICAgICAgKVxuICAgIH1cbn1cbiJdfQ==